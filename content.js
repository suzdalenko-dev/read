let content = [
    {
        id: 0,
        title: "¬øPor qu√© la vivienda y el alquiler son tan caros en Espa√±a? Una bomba social en plena cuenta atr√°s",
        preview: "/assets/img/0-0.webp",
        content: `En Espa√±a, encontrar una vivienda digna a un precio razonable se ha convertido en una aut√©ntica odisea. 
                    Comprar un piso o incluso alquilar uno, especialmente en las grandes ciudades, se ha transformado en un lujo que muchos no pueden permitirse. ¬øPero por qu√©? ¬øQu√© nos ha llevado hasta aqu√≠? 
                    ¬øY, lo m√°s importante, qu√© demonios se puede hacer al respecto?
                    <br><br><img src="/assets/img/0-1.webp" alt="Pol√≠ticos ciegos, pueblo ahogado" class="img-fluid" /><br><br>
                    <h4>#1. El ladrillo como refugio para el ahorro</h4>
                    <br>
                    En un pa√≠s donde los bancos no ofrecen pr√°cticamente rentabilidad por los ahorros y la cultura del ahorro tradicional sigue muy viva, ¬øqu√© hace la gente cuando tiene dinero? Lo mete en ladrillo. Comprar una vivienda se ha convertido en una de las pocas formas de "guardar" valor, de protegerse del futuro, y de paso, alquilarla o venderla m√°s adelante con beneficios. Y esto no es algo que ocurra solo a nivel nacional.
                    <br><br>
                    <h4>#2. Espa√±a, para√≠so del comprador extranjero</h4>
                    <br>
                    Espa√±a se ha convertido en el destino ideal para extranjeros con alto poder adquisitivo. Desde alemanes, brit√°nicos o franceses hasta fondos de inversi√≥n internacionales que ven en nuestras ciudades y costas una oportunidad dorada. ¬øConsecuencia directa? Aumenta la presi√≥n sobre los precios, y el espa√±ol medio, con su sueldo congelado y su bolsillo cada vez m√°s exprimido, simplemente no puede competir. Con esto no pretendo decir que hay que prohibir comprar las viviendas a un inverson extranjero, si no simplemente es un punto m√°s que hay que tener en cuenta. Y el problema principal en esta cuestion esta que en el que el "comprador nacional" no puede competir con el "comprador extranjero" pricisamente por el bajo poder adquisitivo del "comprador nacional". 
                    <br><br>
                    <h4>#3. La inseguridad jur√≠dica y la plaga de la ocupaci√≥n</h4>
                    <br>
                    Y aqu√≠ viene lo m√°s sangrante: la inseguridad. ¬øQu√© propietario se anima a alquilar si sabe que, si le ocupan el piso, tendr√° que armarse de paciencia, dinero y abogados durante meses (o a√±os) para recuperarlo? Es absurdo. El gobierno, en vez de proteger a quien ha trabajado toda su vida para comprarse una casa, parece premiar al ocupa. S√≠, has le√≠do bien: m√°s derechos para el que entra a la fuerza que para el leg√≠timo due√±o. Resultado: miles y miles de viviendas cerradas a cal y canto. Y eso, evidentemente, reduce la oferta y dispara el precio del alquiler.
                    <br><br>
                    <h4>4. El nivel adquisitivo bajo y el infierno fiscal espa√±ol</h4>
                    <br>
                    Sumemos a todo esto unos salarios miserables y una carga fiscal que da miedo. Pagamos impuestos como si vivi√©ramos en Suiza, pero los servicios p√∫blicos, en muchos casos, rozan la chapuza. No hay vivienda p√∫blica suficiente, ni medidas reales para incentivar el alquiler, ni ayudas que lleguen a quien realmente las necesita. Lo que s√≠ hay es burocracia, papeleo, y p√©rdida de tiempo.
                    <br><img src="/assets/img/0-2.webp" alt="¬øPropietario o reh√©n?" class="img-fluid" /><br><br>
                    <h4>5. Las ‚Äúayudas al alquiler‚Äù: otra tomadura de pelo</h4>
                    Se llenan la boca hablando de ‚Äúayudas al alquiler‚Äù. Pero cuando rascas un poco ves el chiste: limitadas por edad, por mil requisitos, gestionadas por oficinas que cuestan millones en sueldos, electricidad y mantenimiento. Y mientras tanto, para financiar estas ayudas, te crujen a impuestos a ti, que trabajas, que pagas, que cumples. Es decir, primero te dejan sin dinero y luego te venden la limosna como si fuera un favor.
                    <br><br>
                    Y a√∫n hay m√°s: la gente tiene que dar vueltas presentando documentos, perdiendo d√≠as de trabajo o haciendo colas infinitas. ¬øY al final? Ni siquiera est√° garantizado que la ayuda llegue. Cuando se hace el c√°lculo global, lo que se ha gastado para dar esas ayudas supera con creces el beneficio real. Un sinsentido.
                    <br><br>   
                    <h3>¬øQu√© se puede hacer?</h3>
                    S√≠, hay soluciones. No son f√°ciles, no son r√°pidas, pero son reales.
                    <br><br>
                    ‚úÖ Desahucio expr√©s y polic√≠a local que sirva para algo
                    Basta ya de premiar al que ocupa. Si alguien irrumpe en tu propiedad, el proceso deber√≠a ser simple: una llamada a la polic√≠a local y desalojo inmediato. Punto. Porque esa misma polic√≠a, que cuesta un dineral a los contribuyentes, est√° muchas veces dando vueltas por el pueblo sin m√°s. Que al menos sirva para algo √∫til: proteger al ciudadano honesto.
                    <br><br>
                    ‚úÖ Seguridad jur√≠dica para el propietario = m√°s oferta = alquileres m√°s bajos
                    Si se garantiza que el propietario no va a perder su casa por alquilarla, habr√° m√°s viviendas en el mercado. Y como en cualquier mercado, cuando hay m√°s oferta, bajan los precios. Es tan sencillo como eso.
                    <br><br>
                    ‚úÖ Menos impuestos, m√°s poder adquisitivo
                    Si bajamos la presi√≥n fiscal sobre los trabajadores, si dejamos de asfixiar a la clase media, la gente tendr√° m√°s dinero en el bolsillo. Y si hay m√°s dinero, hay m√°s consumo, m√°s movimiento, m√°s econom√≠a real. Pero claro, eso requiere trabajo serio, no propaganda de saldo.
                    <br><br>
                    ‚úÖ Revitalizar la Espa√±a vaciada
                    No todo el mundo quiere vivir en Madrid o Barcelona. Pero tampoco se puede vivir en un pueblo donde no hay m√©dicos, ni internet, ni oportunidades. Invertir en la Espa√±a rural ser√≠a una medida de largo plazo, pero real. No fotos para Twitter, sino escuelas, centros de salud, transporte. Vida, en definitiva.
                    <br><br>
                    <h3>Conclusi√≥n: basta de parches, hace falta visi√≥n</h3>
                    Lo que vemos hoy en el mercado inmobiliario espa√±ol es el resultado de a√±os de decisiones mal tomadas, de mirar para otro lado, de contentarse con medidas in√∫tiles. Hay que proteger al que cumple, al que trabaja, al que se esfuerza. Hay que dejarse de ideolog√≠a barata y actuar con sentido com√∫n.
                    <br><br>
                    Porque si seguimos as√≠, el futuro no traer√° ni vivienda, ni alquileres asequibles, ni dignidad para el ciudadano. Solo m√°s frustraci√≥n, m√°s desigualdad‚Ä¶ y m√°s ocupas.
                    <br><br>
                    <h3>‚ùå Y lo peor: una clase pol√≠tica inepta, ciega y completamente desconectada de la realidad</h3>
                    <br><br>
                    Pero si hay algo que agrava esta situaci√≥n todav√≠a m√°s es el nivel lamentable de nuestra clase pol√≠tica. Ineptos, ciegos y, con perd√≥n, gilipollas. En vez de estar centrados en solucionar los problemas reales que afectan a millones de espa√±oles ‚Äîcomo el precio de la vivienda, los sueldos rid√≠culos o la falta de oportunidades‚Äî est√°n m√°s preocupados por cambiar el lenguaje, inventar g√©neros nuevos o montar debates est√©riles sobre ‚Äúelles‚Äù, ‚Äúellxs‚Äù y dem√°s tonter√≠as de sal√≥n.
                    <br><br>
                    ¬øSoluciones reales? Cero. ¬øPol√≠ticas que de verdad impacten en la vida de la gente? Nada. Solo postureo, propaganda y una desconexi√≥n total de lo que pasa en la calle. Mientras tanto, siguen trayendo a Espa√±a a gente    que muchas veces no comparte ni respeta los valores de Europa, ni de nuestra sociedad, ni de nuestra convivencia. Y no contentos con eso, meten ruido con ideolog√≠as extremas, con teor√≠as absurdas sobre identidad, mientras la gente aqu√≠ no puede ni pagar un alquiler digno.
                    <br><br>
                    En resumen: est√°n haciendo cualquier cosa menos lo que tienen que hacer. Son incapaces de gestionar, de priorizar, de tener un m√≠nimo de sentido com√∫n. Mientras tanto, t√∫, yo, y la mayor√≠a, seguimos pagando la fiesta.
                    <br><br>
                    <h3>üï∞Ô∏è Es la hora de cambiar las cosas</h3>
                    Ya est√° bien. Ya va siendo hora de despertar. De exigir soluciones reales, no parches. De dejar de votar al que promete humo y empezar a apoyar a quien defienda con hechos la dignidad de vivir en Espa√±a. Hay que devolver la seguridad al propietario, mejorar el poder adquisitivo del ciudadano, y dejar de lado las ideolog√≠as baratas que solo distraen del verdadero desastre que tenemos encima.
                    <br><br>
                    Porque si no lo hacemos nosotros, no lo va a hacer nadie.
                    <br>
                    Porque merecemos un pa√≠s donde vivir no sea un lujo.
                    <br>
                    Porque ya toca que Espa√±a funcione para los que trabajan, para los que se esfuerzan, para los que la sostienen cada d√≠a.
                    `,
        slug:"Por-qu√©-la-vivienda-y-el-alquiler-son-tan-caros-en-Espa√±a",
        tags: ["Social", "Alquiler", "Vivienda"],
        date: "23/03/2025",
        description: "El problema de la vivienda en Espa√±a no se resolver√° con medidas superficiales ni con ideolog√≠as vac√≠as. Es necesario un cambio real en la gesti√≥n pol√≠tica, con soluciones pr√°cticas que protejan a quienes trabajan y contribuyen al pa√≠s. Sin acci√≥n efectiva, la situaci√≥n solo empeorar√°, aumentando la desigualdad y la frustraci√≥n de los ciudadanos."
    },
     {
        id: 1,
        title: "Inteligencia Artificial en JavaScript",
        preview: "https://suzdalenko-dev.github.io/ia/img/1-3.png",
        content: `<p>
                    La inteligencia artificial (IA) se ha convertido en una de las tecnolog√≠as m√°s innovadoras del desarrollo de software moderno.
                    Pero, ¬øc√≥mo funciona realmente una red neuronal desde adentro? Para comprenderlo paso a paso, vamos a crear una red neuronal muy b√°sica
                    usando solo JavaScript puro ‚Äîsin bibliotecas externas.
                    </p>

                    <h4>#1. Ejemplo b√°sico: Una neurona artificial en JavaScript</h4>

                    <p>
                        Una neurona artificial es la unidad fundamental de una red neuronal. Su comportamiento puede modelarse usando tres componentes esenciales:
                    </p>

                    <ul>
                      <li><strong>üìå Pesos (Weights):</strong>Los pesos determinan la influencia de cada entrada en la neurona. Son valores num√©ricos que multiplican las entradas. <br>
                          üëâ Ejemplo: <br>
                          Si tienes una entrada x = 0.3 y un peso w=0.8, el resultado ponderado ser√°: <br>
                          x √ó w = 0.3 √ó 0.8 = 0.24 <br>
                          Un peso alto significa que la entrada tiene m√°s impacto en la salida de la neurona. <br>
                      </li>
                      <li><strong>üìå 2. Sesgo (Bias):</strong> El sesgo es un n√∫mero que se suma al c√°lculo final de la neurona. Permite desplazar la funci√≥n de activaci√≥n para que la neurona pueda responder mejor a diferentes casos. <br>
                          üëâ Ejemplo: <br>
                          Si la salida ponderada es 0.24 y el sesgo es 0.1, entonces: <br>
                          0.24 + 0.1 = 0.34 <br>
                          El sesgo ayuda a la neurona a no depender exclusivamente de las entradas y a tomar decisiones m√°s flexibles. <br>
                      </li>
                      <li><strong>üìå 3. Funci√≥n de activaci√≥n:</strong> Esta funci√≥n decide si la neurona se "activa" o no. En este caso, usaremos un umbral simple: <br>
                          Si¬†el¬†valor¬†es¬†menor¬†que¬†0.5,¬†la¬†neurona¬†devuelve¬†0;¬†de¬†lo¬†contrario,¬†devuelve¬†1. <br>
                          function activation(x) { return x < 0.5 ? 0 : 1; } <br><br>
                      </li>
                    </ul>
                    <img src="https://suzdalenko-dev.github.io/ia/img/0-1.png" alt="Perceptr√≥n" class="img-fluid" /><br><br>
                        
                    <p><strong>ü§ñ C√≥digo: Perceptr√≥n en JavaScript (con explicaci√≥n)</strong></p>
                    <div class="vscode-header">perceptron.js</div>
                    <div class="vscode-editor">
                    <code>
                    <span class="comment">// Clase que representa una neurona artificial tipo Perceptr√≥n</span><br>
                    <span class="keyword">class</span> <span class="variable">Perceptron</span> {<br><br>
                    &nbsp;&nbsp;<span class="comment">// Constructor: inicializa el peso, el sesgo y la tasa de aprendizaje</span><br>
                    &nbsp;&nbsp;<span class="method">constructor</span>() {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Peso (Weight): determina cu√°nta influencia tiene la entrada</span><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">weight</span> = <span class="method">Math</span>.<span class="method">random</span>();<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Sesgo (Bias): permite desplazar la funci√≥n de activaci√≥n</span><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">bias</span> = <span class="method">Math</span>.<span class="method">random</span>();<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Learning rate: controla la velocidad de aprendizaje</span><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">learningRate</span> = <span class="number">0.1</span>;<br>
                    &nbsp;&nbsp;}<br><br>
                    &nbsp;&nbsp;<span class="comment">// Funci√≥n de activaci√≥n:</span><br>
                    &nbsp;&nbsp;<span class="comment">// Devuelve 1 si la suma ponderada supera el umbral (0.5), 0 en caso contrario</span><br>
                    &nbsp;&nbsp;<span class="method">activation</span>(<span class="variable">x</span>) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> <span class="variable">x</span> &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">0</span>;<br>
                    &nbsp;&nbsp;}<br><br>
                    &nbsp;&nbsp;<span class="comment">// Predicci√≥n: calcula la salida del perceptr√≥n</span><br>
                    &nbsp;&nbsp;<span class="comment">// Suma ponderada: input * peso + sesgo</span><br>
                    &nbsp;&nbsp;<span class="method">predict</span>(<span class="variable">input</span>) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> <span class="variable">sum</span> = <span class="variable">input</span> * <span class="keyword">this</span>.<span class="variable">weight</span> + <span class="keyword">this</span>.<span class="variable">bias</span>;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> <span class="keyword">this</span>.<span class="method">activation</span>(<span class="variable">sum</span>);<br>
                    &nbsp;&nbsp;}<br><br>
                    &nbsp;&nbsp;<span class="comment">// Entrenamiento: ajusta peso y sesgo durante 200 √©pocas</span><br>
                    &nbsp;&nbsp;<span class="method">train</span>(<span class="variable">inputs</span>, <span class="variable">labels</span>, <span class="variable">epochs</span> = <span class="number">200</span>) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>; <span class="variable">i</span> &lt; <span class="variable">epochs</span>; <span class="variable">i</span>++) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable">j</span> = <span class="number">0</span>; <span class="variable">j</span> &lt; <span class="variable">inputs</span>.<span class="method">length</span>; <span class="variable">j</span>++) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> <span class="variable">prediction</span> = <span class="keyword">this</span>.<span class="method">predict</span>(<span class="variable">inputs</span>[<span class="variable">j</span>]);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> <span class="variable">error</span> = <span class="variable">labels</span>[<span class="variable">j</span>] - <span class="variable">prediction</span>;<br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Ajuste del peso y del sesgo basado en el error</span><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">weight</span> += <span class="variable">error</span> * <span class="variable">inputs</span>[<span class="variable">j</span>] * <span class="keyword">this</span>.<span class="variable">learningRate</span>;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">bias</span> += <span class="variable">error</span> * <span class="keyword">this</span>.<span class="variable">learningRate</span>;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;}<br>
                    }<br><br>
                    <span class="comment">// Crear y entrenar el perceptr√≥n</span><br>
                    <span class="keyword">let</span> <span class="variable">perceptron</span> = <span class="keyword">new</span> <span class="variable">Perceptron</span>();<br><br>
                    <span class="comment">// Entrenamos con datos: menores a 0.5 = 0, mayores o iguales = 1</span><br>
                    <span class="keyword">let</span> <span class="variable">trainingInputs</span> = [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.333</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">0.9</span>];<br>
                    <span class="keyword">let</span> <span class="variable">trainingLabels</span> = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];<br><br>
                    <span class="variable">perceptron</span>.<span class="method">train</span>(<span class="variable">trainingInputs</span>, <span class="variable">trainingLabels</span>);<br><br>
                    <span class="comment">// Probamos el perceptr√≥n</span><br>
                    <span class="variable">console</span>.<span class="method">log</span>(<span class="string">"Predicci√≥n para 0.3:"</span>, <span class="variable">perceptron</span>.<span class="method">predict</span>(<span class="number">0.3</span>));<br>
                    <span class="variable">console</span>.<span class="method">log</span>(<span class="string">"Predicci√≥n para 0.7:"</span>, <span class="variable">perceptron</span>.<span class="method">predict</span>(<span class="number">0.7</span>));<br><br>
                    <span class="comment">// Mostrar los pesos aprendidos</span><br>
                    <span class="variable">console</span>.<span class="method">log</span>(<span class="string">"Peso:"</span>, <span class="variable">perceptron</span>.<span class="variable">weight</span>);<br>
                    <span class="variable">console</span>.<span class="method">log</span>(<span class="string">"Sesgo:"</span>, <span class="variable">perceptron</span>.<span class="variable">bias</span>);
                      </code>
                    </div>

         <br>            
        <p>
          Resultado de la ejecuci√≥n del c√≥digo anterior:
        </p>
        <iframe width="100%" height="111px" src="https://suzdalenko-dev.github.io/ia/0.js/0.html" title="Inteligencia Artificial en JavaScript"></iframe>            
         <p>
          Este c√≥digo nos muestra c√≥mo funciona la inteligencia artificial utilizando una sola neurona artificial, llamada perceptr√≥n.<br><br>
          Primero, se entrena con ejemplos de entrada como 0.1, 0.2, 0.333, 0.4, 0.5, 0.8, y 0.9, junto con sus resultados esperados: [0, 0, 0, 0, 1, 1, 1].
          A partir de estos datos, la IA ajusta autom√°ticamente los pesos y el sesgo para aprender a distinguir entre valores bajos (0) y altos (1).<br><br>
          Una vez entrenado, podemos darle nuevos valores como 0.3 y 0.7, y el perceptr√≥n nos devolver√° predicciones razonables, en este caso 0 para el valor bajo y 1 para el alto.
        </p>            
        <p>
          Un lector curioso podr√≠a preguntarse:
        </p>            
        <p>
          <strong>"¬øY no ser√≠a m√°s f√°cil usar una simple comparaci√≥n como if (x < 0.5) return 0; else return 1 en lugar de todo este entrenamiento con bucles, ajustes de pesos y dem√°s?"
          </strong>
        </p>
        <p>
          Y justamente ah√≠ est√° lo interesante.
        </p>
        <p>
          El perceptr√≥n no se limita a hacer una comparaci√≥n est√°tica. Ajusta sus propios par√°metros (peso y sesgo) a partir de ejemplos reales. Aunque en el primer caso puede parecer que solo est√° imitando un if, en realidad est√° aprendiendo a generalizar una regla a partir de datos. Es decir, no le decimos directamente c√≥mo tomar decisiones, sino que las aprende por s√≠ mismo.
        </p>
        <p>
          <strong>¬ø Pero‚Ä¶ ¬øqu√© pasa cuando el problema no es tan simple ?</strong>
        </p>
        <p>
          Para entender por qu√© esto es importante, vamos a construir una red un poco m√°s avanzada. En este nuevo ejemplo usaremos 3 neuronas en la capa oculta (una para cada bit de entrada) y una neurona final que eval√∫a la salida combinada.
        </p>
        <p>
          Vamos ahora a ver un ejemplo en el que una simple condici√≥n if no es suficiente.
        </p>
        <p>
          En lugar de entradas individuales como 0.3 o 0.7, ahora trabajaremos con combinaciones binarias de tres valores. Esto genera una l√≥gica m√°s compleja, donde no basta con comparar un solo n√∫mero para tomar una decisi√≥n. Observa los siguientes ejemplos de entrenamiento: <br>
          000 ‚Üí resultado: 0  <br>
          001 ‚Üí resultado: 0  <br>
          010 ‚Üí resultado: 0  <br>
          100 ‚Üí resultado: 1  <br>
          110 ‚Üí resultado: 1  <br>
          111 ‚Üí resultado: 1  <br>
        </p>
        <p>
          Como puedes ver, no hay un solo valor que puedas comparar con un umbral para decidir entre 0 o 1. No podr√≠amos escribir simplemente if (x < 0.5) porque x ahora es un conjunto de bits, y la respuesta depende de c√≥mo interact√∫an entre ellos.
        </p>
        <h6>üß† ¬øC√≥mo lo resolvemos entonces?</h6>
        <p>
          Para este caso, vamos a construir una red neuronal multicapa: <br>
            üîπ Una primera capa compuesta por 3 neuronas, cada una especializada en uno de los bits de entrada. <br>
            üîπ Una segunda capa con una sola neurona de salida, que recibe las salidas de las 3 anteriores y toma la decisi√≥n final. <br>
            üîπ Y en lugar de una funci√≥n if, usamos una funci√≥n de activaci√≥n sigmoide: <br>
            <strong>return 1 / (1 + Math.exp(-x)); </strong><br>
            Esta funci√≥n es m√°s suave, permite valores intermedios entre 0 y 1, y hace que el aprendizaje sea mucho m√°s realista y √∫til.
        </p>
        <p>
          Con este enfoque, la red aprende a combinar patrones entre los distintos bits de entrada y a sacar conclusiones, incluso sobre datos que no ha visto nunca.
        </p>
        <p>
          Este tipo de arquitectura, aunque sencilla, es mucho m√°s poderosa que un if, porque representa la esencia de c√≥mo una inteligencia artificial aprende a pensar por s√≠ sola a partir de ejemplos.
        </p>

        <img src="https://suzdalenko-dev.github.io/ia/img/1-1.png" alt="Red neuronal de 3 neuronas" class="img-fluid" /><br><br>

        <p><strong>ü§ñ C√≥digo: Red neuronal multicapa en JavaScript (con explicaci√≥n)</strong></p>
        <div class="vscode-header">neurona.js</div>
        <div class="vscode-editor">
        <code>
        <span class="comment">// Datos de entrada y etiquetas</span><br>
        <span class="keyword">const</span> <span class="variable">inputs</span> = [<br>
        &nbsp;&nbsp;[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],<br>
        &nbsp;&nbsp;[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],<br>
        &nbsp;&nbsp;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],<br>
        &nbsp;&nbsp;[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],<br>
        &nbsp;&nbsp;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],<br>
        &nbsp;&nbsp;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]<br>
        ];<br>
        <span class="keyword">const</span> <span class="variable">labels</span> = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];<br><br>
        <span class="comment">// Neurona individual con funci√≥n sigmoide</span><br>
        <span class="keyword">class</span> <span class="variable">Neurona</span> {<br>
        &nbsp;&nbsp;<span class="method">constructor</span>(<span class="variable">nombre</span> = <span class="string">""</span>) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">weight</span> = <span class="method">Math</span>.<span class="method">random</span>();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">bias</span> = <span class="method">Math</span>.<span class="method">random</span>();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">learningRate</span> = <span class="number">0.1</span>;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">nombre</span> = <span class="variable">nombre</span>;<br>
        &nbsp;&nbsp;}<br><br>
        &nbsp;&nbsp;<span class="method">activation</span>(<span class="variable">x</span>) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + <span class="method">Math</span>.<span class="method">exp</span>(-<span class="variable">x</span>));<br>
        &nbsp;&nbsp;}<br><br>
        &nbsp;&nbsp;<span class="method">raw</span>(<span class="variable">input</span>) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> <span class="variable">input</span> * <span class="keyword">this</span>.<span class="variable">weight</span> + <span class="keyword">this</span>.<span class="variable">bias</span>;<br>
        &nbsp;&nbsp;}<br><br>
        &nbsp;&nbsp;<span class="method">predict</span>(<span class="variable">input</span>) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> <span class="keyword">this</span>.<span class="method">activation</span>(<span class="keyword">this</span>.<span class="method">raw</span>(<span class="variable">input</span>));<br>
        &nbsp;&nbsp;}<br><br>
        &nbsp;&nbsp;<span class="method">train</span>(<span class="variable">inputs</span>, <span class="variable">labels</span>, <span class="variable">epochs</span> = <span class="number">10</span>) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>; <span class="variable">i</span> &lt; <span class="variable">epochs</span>; <span class="variable">i</span>++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable">j</span> = <span class="number">0</span>; <span class="variable">j</span> &lt; <span class="variable">inputs</span>.<span class="method">length</span>; <span class="variable">j</span>++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">this</span>.<span class="method">predict</span>(<span class="variable">inputs</span>[<span class="variable">j</span>]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> <span class="variable">error</span> = <span class="variable">labels</span>[<span class="variable">j</span>] - <span class="variable">output</span>;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> <span class="variable">gradient</span> = <span class="variable">output</span> * (<span class="number">1</span> - <span class="variable">output</span>);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">weight</span> += <span class="variable">error</span> * <span class="variable">gradient</span> * <span class="variable">inputs</span>[<span class="variable">j</span>] * <span class="keyword">this</span>.<span class="variable">learningRate</span>;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">bias</span> += <span class="variable">error</span> * <span class="variable">gradient</span> * <span class="keyword">this</span>.<span class="variable">learningRate</span>;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}<br><br>
        &nbsp;&nbsp;<span class="method">info</span>() {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">console</span>.<span class="method">log</span>(<span class="keyword">this</span>.<span class="variable">nombre</span>);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">console</span>.<span class="method">log</span>(<span class="string">"  Peso:"</span>, <span class="keyword">this</span>.<span class="variable">weight</span>.<span class="method">toFixed</span>(<span class="number">3</span>));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">console</span>.<span class="method">log</span>(<span class="string">"  Bias:"</span>, <span class="keyword">this</span>.<span class="variable">bias</span>.<span class="method">toFixed</span>(<span class="number">3</span>));<br>
        &nbsp;&nbsp;}<br>
        }<br>
        <span class="comment">// Clase que representa la neurona de salida con m√∫ltiples entradas</span><br>
        <span class="keyword">class</span> <span class="variable">NeuronaSalida</span> {<br>
        &nbsp;&nbsp;<span class="method">constructor</span>(<span class="variable">numEntradas</span>) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Inicializa pesos y bias aleatoriamente</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">weights</span> = <span class="method">Array</span>.<span class="method">from</span>({ length: <span class="variable">numEntradas</span> }, () => <span class="method">Math</span>.<span class="method">random</span>());<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">bias</span> = <span class="method">Math</span>.<span class="method">random</span>();<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">learningRate</span> = <span class="number">0.1</span>;<br>
        &nbsp;&nbsp;}<br><br>
        &nbsp;&nbsp;<span class="comment">// Funci√≥n de activaci√≥n: sigmoide</span><br>
        &nbsp;&nbsp;<span class="method">activation</span>(<span class="variable">x</span>) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + <span class="method">Math</span>.<span class="method">exp</span>(-<span class="variable">x</span>));<br>
        &nbsp;&nbsp;}<br><br>
        &nbsp;&nbsp;<span class="comment">// Predicci√≥n a partir de salidas ocultas</span><br>
        &nbsp;&nbsp;<span class="method">predict</span>(<span class="variable">hiddenOutputs</span>) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> <span class="variable">sum</span> = <span class="variable">hiddenOutputs</span>.<span class="method">reduce</span>((<span class="variable">acc</span>, <span class="variable">h</span>, <span class="variable">i</span>) => <span class="variable">acc</span> + <span class="variable">h</span> * <span class="keyword">this</span>.<span class="variable">weights</span>[<span class="variable">i</span>], <span class="number">0</span>) + <span class="keyword">this</span>.<span class="variable">bias</span>;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> <span class="keyword">this</span>.<span class="method">activation</span>(<span class="variable">sum</span>);<br>
        &nbsp;&nbsp;}<br><br>
        &nbsp;&nbsp;<span class="comment">// Entrenamiento de la neurona de salida</span><br>
        &nbsp;&nbsp;<span class="method">train</span>(<span class="variable">hiddenOutputsList</span>, <span class="variable">labels</span>, <span class="variable">epochs</span> = <span class="number">10</span>) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable">epoch</span> = <span class="number">0</span>; <span class="variable">epoch</span> &lt; <span class="variable">epochs</span>; <span class="variable">epoch</span>++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>; <span class="variable">i</span> &lt; <span class="variable">hiddenOutputsList</span>.<span class="method">length</span>; <span class="variable">i</span>++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">this</span>.<span class="method">predict</span>(<span class="variable">hiddenOutputsList</span>[<span class="variable">i</span>]);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> <span class="variable">error</span> = <span class="variable">labels</span>[<span class="variable">i</span>] - <span class="variable">output</span>;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span> <span class="variable">gradient</span> = <span class="variable">output</span> * (<span class="number">1</span> - <span class="variable">output</span>);<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Ajustar los pesos</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable">j</span> = <span class="number">0</span>; <span class="variable">j</span> &lt; <span class="keyword">this</span>.<span class="variable">weights</span>.<span class="property">length</span>; <span class="variable">j</span>++) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">weights</span>[<span class="variable">j</span>] += <span class="variable">error</span> * <span class="variable">gradient</span> * <span class="variable">hiddenOutputsList</span>[<span class="variable">i</span>][<span class="variable">j</span>] * <span class="keyword">this</span>.<span class="variable">learningRate</span>;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Ajustar el sesgo</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.<span class="variable">bias</span> += <span class="variable">error</span> * <span class="variable">gradient</span> * <span class="keyword">this</span>.<span class="variable">learningRate</span>;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;}<br><br>
        &nbsp;&nbsp;<span class="comment">// Mostrar informaci√≥n de la neurona</span><br>
        &nbsp;&nbsp;<span class="method">info</span>() {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">console</span>.<span class="method">log</span>(<span class="string">"‚öôÔ∏è Neurona de salida:"</span>);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">console</span>.<span class="method">log</span>(<span class="string">"  Pesos:"</span>, <span class="keyword">this</span>.<span class="variable">weights</span>.<span class="method">map</span>(<span class="variable">w</span> => <span class="variable">w</span>.<span class="method">toFixed</span>(<span class="number">3</span>)).<span class="method">join</span>(<span class="string">", "</span>));<br>
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">console</span>.<span class="method">log</span>(<span class="string">"  Bias:"</span>, <span class="keyword">this</span>.<span class="variable">bias</span>.<span class="method">toFixed</span>(<span class="number">3</span>));<br>
        &nbsp;&nbsp;}<br>
        }<br><br>
        <span class="method">console</span>.<span class="method">log</span>(<span class="string">"üì• Datos de entrenamiento:"</span>);<br>
        <span class="variable">inputs</span>.<span class="method">forEach</span>((<span class="variable">input</span>, <span class="variable">i</span>) => {<br>
        &nbsp;&nbsp;<span class="method">console</span>.<span class="method">log</span>(<span class="string">  Input: [input.join(", ")}] ‚Üí Label: labels[i]}</span>);<br>
        });<br><br>
        <span class="comment">// Capa oculta con 3 neuronas (una por cada bit de entrada)</span><br>
        <span class="keyword">const</span> <span class="variable">oculta1</span> = <span class="keyword">new</span> <span class="class">Neurona</span>(<span class="string">"Oculta 1"</span>);<br>
        <span class="keyword">const</span> <span class="variable">oculta2</span> = <span class="keyword">new</span> <span class="class">Neurona</span>(<span class="string">"Oculta 2"</span>);<br>
        <span class="keyword">const</span> <span class="variable">oculta3</span> = <span class="keyword">new</span> <span class="class">Neurona</span>(<span class="string">"Oculta 3"</span>);<br><br>
        <span class="keyword">const</span> <span class="variable">entradasPorNeurona</span> = [<br>
        &nbsp;&nbsp;<span class="variable">inputs</span>.<span class="method">map</span>(<span class="variable">i</span> => <span class="variable">i</span>[<span class="number">0</span>]),<br>
        &nbsp;&nbsp;<span class="variable">inputs</span>.<span class="method">map</span>(<span class="variable">i</span> => <span class="variable">i</span>[<span class="number">1</span>]),<br>
        &nbsp;&nbsp;<span class="variable">inputs</span>.<span class="method">map</span>(<span class="variable">i</span> => <span class="variable">i</span>[<span class="number">2</span>])<br>
        ];<br><br>
        <span class="variable">oculta1</span>.<span class="method">train</span>(<span class="variable">entradasPorNeurona</span>[<span class="number">0</span>], <span class="variable">labels</span>, <span class="number">1000</span>);<br>
        <span class="variable">oculta2</span>.<span class="method">train</span>(<span class="variable">entradasPorNeurona</span>[<span class="number">1</span>], <span class="variable">labels</span>, <span class="number">1000</span>);<br>
        <span class="variable">oculta3</span>.<span class="method">train</span>(<span class="variable">entradasPorNeurona</span>[<span class="number">2</span>], <span class="variable">labels</span>, <span class="number">1000</span>);<br><br>
        <span class="keyword">const</span> <span class="variable">hiddenOutputs</span> = <span class="variable">inputs</span>.<span class="method">map</span>(<span class="variable">input</span> => [<br>
        &nbsp;&nbsp;<span class="variable">oculta1</span>.<span class="method">predict</span>(<span class="variable">input</span>[<span class="number">0</span>]),<br>
        &nbsp;&nbsp;<span class="variable">oculta2</span>.<span class="method">predict</span>(<span class="variable">input</span>[<span class="number">1</span>]),<br>
        &nbsp;&nbsp;<span class="variable">oculta3</span>.<span class="method">predict</span>(<span class="variable">input</span>[<span class="number">2</span>])<br>
        ]);<br><br>
        <span class="keyword">const</span> <span class="variable">salida</span> = <span class="keyword">new</span> <span class="class">NeuronaSalida</span>(<span class="number">3</span>);<br>
        <span class="variable">salida</span>.<span class="method">train</span>(<span class="variable">hiddenOutputs</span>, <span class="variable">labels</span>, <span class="number">1000</span>);<br><br>
        <span class="keyword">function</span> <span class="method">predecir</span>(<span class="variable">binArray</span>) {<br>
        &nbsp;&nbsp;<span class="keyword">const</span> <span class="variable">h1</span> = <span class="variable">oculta1</span>.<span class="method">predict</span>(<span class="variable">binArray</span>[<span class="number">0</span>]);<br>
        &nbsp;&nbsp;<span class="keyword">const</span> <span class="variable">h2</span> = <span class="variable">oculta2</span>.<span class="method">predict</span>(<span class="variable">binArray</span>[<span class="number">1</span>]);<br>
        &nbsp;&nbsp;<span class="keyword">const</span> <span class="variable">h3</span> = <span class="variable">oculta3</span>.<span class="method">predict</span>(<span class="variable">binArray</span>[<span class="number">2</span>]);<br>
        &nbsp;&nbsp;<span class="keyword">const</span> <span class="variable">output</span> = <span class="variable">salida</span>.<span class="method">predict</span>([<span class="variable">h1</span>, <span class="variable">h2</span>, <span class="variable">h3</span>]);<br>
        &nbsp;&nbsp;<span class="keyword">const</span> <span class="variable">clasificacion</span> = <span class="variable">output</span> &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">0</span>;<br>
        }<br><br>
        <span class="comment">// Pruebas con nuevos datos</span><br>
        <span class="method">console</span>.<span class="method">log</span>(<span class="string">"\nüß™ Pruebas con datos no vistos:"</span>);<br>
        <span class="method">predecir</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]); <span class="comment">// 011</span><br>
        <span class="method">predecir</span>([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]); <span class="comment">// 101</span><br><br>
        <span class="comment">// Info de las neuronas</span><br>
        <span class="method">console</span>.<span class="method">log</span>(<span class="string">"\n‚ÑπÔ∏è Pesos y sesgos finales:"</span>);<br>
        <span class="variable">oculta1</span>.<span class="method">info</span>();<br>
        <span class="variable">oculta2</span>.<span class="method">info</span>();<br>
        <span class="variable">oculta3</span>.<span class="method">info</span>();<br>
        <span class="variable">salida</span>.<span class="method">info</span>();<br>
        </code>
        </div>
        <p>
          Resultado de la ejecuci√≥n del c√≥digo anterior:
        </p>
        <iframe width="100%" height="411px" src="https://suzdalenko-dev.github.io/ia/0.js/1.html" title="Inteligencia Artificial en JavaScript"></iframe>   
        <p>
          üìä Resultados del entrenamiento y prueba de la red neuronal:
          <br>
          Despu√©s de entrenar nuestra red neuronal en JavaScript con los siguientes datos:
          Input: [0, 0, 0] ‚Üí resultado: 0  <br>
          Input: [0, 0, 1] ‚Üí resultado: 0  <br>
          Input: [0, 1, 0] ‚Üí resultado: 0  <br>
          Input: [1, 0, 0] ‚Üí resultado: 1  <br>
          Input: [1, 1, 0] ‚Üí resultado: 1  <br>
          Input: [1, 1, 1] ‚Üí resultado: 1  <br><br>
          La inteligencia artificial fue capaz de generalizar el patr√≥n correctamente. Al presentarle entradas no vistas previamente, como:<br>
          Input: [0, 1, 1] ‚Üí Oculta: [0.08, 0.67, 0.50] ‚Üí Salida: 0 (confianza: 0.091)  <br>
          Input: [1, 0, 1] ‚Üí Oculta: [0.93, 0.33, 0.50] ‚Üí Salida: 1 (confianza: 0.922)  <br><br>
          la IA respondi√≥ con precisi√≥n y gran confianza.
        </p>
        <p>
        üß† ¬øQu√© significa esto?
        </p>
        <p>
        Aunque el problema puede parecer simple para un humano (basta con fijarse en el primer bit de entrada para predecir el resultado), la red no fue programada expl√≠citamente para eso. En su lugar, la IA fue capaz de descubrir esta regla por s√≠ sola, aprendiendo a trav√©s del entrenamiento.
        </p>
        <p>
          ‚úÖ En resumen, esta demostraci√≥n muestra c√≥mo una red neuronal sencilla, escrita en JavaScript, puede aprender patrones l√≥gicos sin instrucciones expl√≠citas. Es un claro ejemplo del poder del aprendizaje autom√°tico.
        </p>`,
        slug:"Inteligencia-Artificial-en-JavaScript",
        tags: ["Desarrollo", "IA", "JavaScript", "Perceptron"],
        date: "06/04/2025",
        description: `En este art√≠culo, construimos una neurona artificial b√°sica en JavaScript, entendiendo los conceptos clave de pesos, sesgos y funciones de activaci√≥n. Hemos visto que el perceptr√≥n puede aprender por s√≠ solo a partir de datos, sin necesidad de que le demos reglas expl√≠citas. La inteligencia artificial, en su n√∫cleo, es una funci√≥n matem√°tica que transforma entradas en salidas mediante una serie de c√°lculos. En las redes neuronales, esto implica multiplicar cada entrada por un peso, sumar un sesgo y aplicar una funci√≥n de activaci√≥n para obtener una decisi√≥n. A trav√©s del aprendizaje, estos valores se ajustan autom√°ticamente para mejorar la precisi√≥n del modelo.`
    },
     {
        id: 2,
        title: "Autentificaci√≥n con JWT Token en Python Django",
        preview: "https://suzdalenko-dev.github.io/ia/img/2-0.png",
        content: `Autentificaci√≥n con JWT Token en Python Django`,
        slug:"Python-Django-JWT-Token",
        tags: ["JWT", "Python", "Django", "Autentificaci√≥n"],
        date: "23/03/2025",
        description: "Autentificacion con JWT Token en Python Django"
    },
];

content = content.reverse();

window.content = content;
